From 4025a087cfbd0f8940b30819b8804de257262575 Mon Sep 17 00:00:00 2001
From: Michael Allwright <allsey87@gmail.com>
Date: Thu, 15 Apr 2021 16:02:11 +0200
Subject: [PATCH] usb3503: Disable regmap configuration during connect

---
 drivers/usb/misc/usb3503.c | 79 +++++++++++++++++++-------------------
 1 file changed, 40 insertions(+), 39 deletions(-)

diff --git a/drivers/usb/misc/usb3503.c b/drivers/usb/misc/usb3503.c
index 37c5af569fe8..3d1e8564da8b 100644
--- a/drivers/usb/misc/usb3503.c
+++ b/drivers/usb/misc/usb3503.c
@@ -74,45 +74,46 @@ static int usb3503_connect(struct usb3503 *hub)
 
 	usb3503_reset(hub, 1);
 
-	if (hub->regmap) {
-		/* SP_ILOCK: set connect_n, config_n for config */
-		err = regmap_write(hub->regmap, USB3503_SP_ILOCK,
-			   (USB3503_SPILOCK_CONNECT
-				 | USB3503_SPILOCK_CONFIG));
-		if (err < 0) {
-			dev_err(dev, "SP_ILOCK failed (%d)\n", err);
-			return err;
-		}
-
-		/* PDS : Set the ports which are disabled in self-powered mode. */
-		if (hub->port_off_mask) {
-			err = regmap_update_bits(hub->regmap, USB3503_PDS,
-					hub->port_off_mask,
-					hub->port_off_mask);
-			if (err < 0) {
-				dev_err(dev, "PDS failed (%d)\n", err);
-				return err;
-			}
-		}
-
-		/* CFG1 : Set SELF_BUS_PWR, this enables self-powered operation. */
-		err = regmap_update_bits(hub->regmap, USB3503_CFG1,
-					 USB3503_SELF_BUS_PWR,
-					 USB3503_SELF_BUS_PWR);
-		if (err < 0) {
-			dev_err(dev, "CFG1 failed (%d)\n", err);
-			return err;
-		}
-
-		/* SP_LOCK: clear connect_n, config_n for hub connect */
-		err = regmap_update_bits(hub->regmap, USB3503_SP_ILOCK,
-					 (USB3503_SPILOCK_CONNECT
-					  | USB3503_SPILOCK_CONFIG), 0);
-		if (err < 0) {
-			dev_err(dev, "SP_ILOCK failed (%d)\n", err);
-			return err;
-		}
-	}
+	/* disable regmap connect logic */
+	// if (hub->regmap) {
+	// 	/* SP_ILOCK: set connect_n, config_n for config */
+	// 	err = regmap_write(hub->regmap, USB3503_SP_ILOCK,
+	// 		   (USB3503_SPILOCK_CONNECT
+	// 			 | USB3503_SPILOCK_CONFIG));
+	// 	if (err < 0) {
+	// 		dev_err(dev, "SP_ILOCK failed (%d)\n", err);
+	// 		return err;
+	// 	}
+
+	// 	/* PDS : Set the ports which are disabled in self-powered mode. */
+	// 	if (hub->port_off_mask) {
+	// 		err = regmap_update_bits(hub->regmap, USB3503_PDS,
+	// 				hub->port_off_mask,
+	// 				hub->port_off_mask);
+	// 		if (err < 0) {
+	// 			dev_err(dev, "PDS failed (%d)\n", err);
+	// 			return err;
+	// 		}
+	// 	}
+
+	// 	/* CFG1 : Set SELF_BUS_PWR, this enables self-powered operation. */
+	// 	err = regmap_update_bits(hub->regmap, USB3503_CFG1,
+	// 				 USB3503_SELF_BUS_PWR,
+	// 				 USB3503_SELF_BUS_PWR);
+	// 	if (err < 0) {
+	// 		dev_err(dev, "CFG1 failed (%d)\n", err);
+	// 		return err;
+	// 	}
+
+	// 	/* SP_LOCK: clear connect_n, config_n for hub connect */
+	// 	err = regmap_update_bits(hub->regmap, USB3503_SP_ILOCK,
+	// 				 (USB3503_SPILOCK_CONNECT
+	// 				  | USB3503_SPILOCK_CONFIG), 0);
+	// 	if (err < 0) {
+	// 		dev_err(dev, "SP_ILOCK failed (%d)\n", err);
+	// 		return err;
+	// 	}
+	// }
 
 	if (hub->connect)
 		gpiod_set_value_cansleep(hub->connect, 1);
-- 
2.17.1

