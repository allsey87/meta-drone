From ddb05f81ca71ed802f63148d8da06b1f26e7cb97 Mon Sep 17 00:00:00 2001
From: Michael Allwright <allsey87@gmail.com>
Date: Wed, 14 Apr 2021 17:20:37 +0200
Subject: [PATCH] usb3503: Use driver from upstream kernel

---
 drivers/usb/misc/usb3503.c            | 204 ++++++++++----------------
 include/linux/platform_data/usb3503.h |   3 -
 2 files changed, 80 insertions(+), 127 deletions(-)

diff --git a/drivers/usb/misc/usb3503.c b/drivers/usb/misc/usb3503.c
index 72f39a9751b5..37c5af569fe8 100644
--- a/drivers/usb/misc/usb3503.c
+++ b/drivers/usb/misc/usb3503.c
@@ -7,11 +7,10 @@
 
 #include <linux/clk.h>
 #include <linux/i2c.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/usb3503.h>
 #include <linux/regmap.h>
@@ -47,19 +46,19 @@ struct usb3503 {
 	struct device		*dev;
 	struct clk		*clk;
 	u8	port_off_mask;
-	int	gpio_intn;
-	int	gpio_reset;
-	int	gpio_connect;
+	struct gpio_desc	*intn;
+	struct gpio_desc 	*reset;
+	struct gpio_desc 	*connect;
 	bool	secondary_ref_clk;
 };
 
 static int usb3503_reset(struct usb3503 *hub, int state)
 {
-	if (!state && gpio_is_valid(hub->gpio_connect))
-		gpio_set_value_cansleep(hub->gpio_connect, 0);
+	if (!state && hub->connect)
+		gpiod_set_value_cansleep(hub->connect, 0);
 
-	if (gpio_is_valid(hub->gpio_reset))
-		gpio_set_value_cansleep(hub->gpio_reset, state);
+	if (hub->reset)
+		gpiod_set_value_cansleep(hub->reset, !state);
 
 	/* Wait T_HUBINIT == 4ms for hub logic to stabilize */
 	if (state)
@@ -115,8 +114,8 @@ static int usb3503_connect(struct usb3503 *hub)
 		}
 	}
 
-	if (gpio_is_valid(hub->gpio_connect))
-		gpio_set_value_cansleep(hub->gpio_connect, 1);
+	if (hub->connect)
+		gpiod_set_value_cansleep(hub->connect, 1);
 
 	hub->mode = USB3503_MODE_HUB;
 	dev_info(dev, "switched to HUB mode\n");
@@ -158,131 +157,90 @@ static const struct regmap_config usb3503_regmap_config = {
 static int usb3503_probe(struct usb3503 *hub)
 {
 	struct device *dev = hub->dev;
-	struct usb3503_platform_data *pdata = dev_get_platdata(dev);
-	struct device_node *np = dev->of_node;
 	int err;
 	u32 mode = USB3503_MODE_HUB;
-	const u32 *property;
+	enum gpiod_flags flags;
 	int len;
 
-	if (pdata) {
-		hub->port_off_mask	= pdata->port_off_mask;
-		hub->gpio_intn		= pdata->gpio_intn;
-		hub->gpio_connect	= pdata->gpio_connect;
-		hub->gpio_reset		= pdata->gpio_reset;
-		hub->mode		= pdata->initial_mode;
-	} else if (np) {
-		u32 rate = 0;
-		hub->port_off_mask = 0;
-
-		if (!of_property_read_u32(np, "refclk-frequency", &rate)) {
-			switch (rate) {
-			case 38400000:
-			case 26000000:
-			case 19200000:
-			case 12000000:
-				hub->secondary_ref_clk = 0;
-				break;
-			case 24000000:
-			case 27000000:
-			case 25000000:
-			case 50000000:
-				hub->secondary_ref_clk = 1;
-				break;
-			default:
-				dev_err(dev,
-					"unsupported reference clock rate (%d)\n",
-					(int) rate);
-				return -EINVAL;
-			}
-		}
-
-		hub->clk = devm_clk_get_optional(dev, "refclk");
-		if (IS_ERR(hub->clk)) {
-			dev_err(dev, "unable to request refclk (%ld)\n",
-					PTR_ERR(hub->clk));
-			return PTR_ERR(hub->clk);
-		}
-
-		if (rate != 0) {
-			err = clk_set_rate(hub->clk, rate);
-			if (err) {
-				dev_err(dev,
-					"unable to set reference clock rate to %d\n",
-					(int)rate);
-				return err;
-			}
-		}
-
-		err = clk_prepare_enable(hub->clk);
-		if (err) {
-			dev_err(dev, "unable to enable reference clock\n");
-			return err;
-		}
-
-		property = of_get_property(np, "disabled-ports", &len);
-		if (property && (len / sizeof(u32)) > 0) {
-			int i;
-			for (i = 0; i < len / sizeof(u32); i++) {
-				u32 port = be32_to_cpu(property[i]);
-				if ((1 <= port) && (port <= 3))
-					hub->port_off_mask |= (1 << port);
-			}
+	u32 rate = 0;
+	hub->port_off_mask = 0;
+
+	if (!device_property_read_u32(dev, "refclk-frequency", &rate)) {
+		switch (rate) {
+		case 38400000:
+		case 26000000:
+		case 19200000:
+		case 12000000:
+			hub->secondary_ref_clk = 0;
+			break;
+		case 24000000:
+		case 27000000:
+		case 25000000:
+		case 50000000:
+			hub->secondary_ref_clk = 1;
+			break;
+		default:
+			dev_err(dev,
+				"unsupported reference clock rate (%d)\n",
+				(int) rate);
+			return -EINVAL;
 		}
-
-		hub->gpio_intn	= of_get_named_gpio(np, "intn-gpios", 0);
-		if (hub->gpio_intn == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		hub->gpio_connect = of_get_named_gpio(np, "connect-gpios", 0);
-		if (hub->gpio_connect == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		hub->gpio_reset = of_get_named_gpio(np, "reset-gpios", 0);
-		if (hub->gpio_reset == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		of_property_read_u32(np, "initial-mode", &mode);
-		hub->mode = mode;
 	}
 
-	if (hub->port_off_mask && !hub->regmap)
-		dev_err(dev, "Ports disabled with no control interface\n");
+	hub->clk = devm_clk_get_optional(dev, "refclk");
+	if (IS_ERR(hub->clk)) {
+		dev_err(dev, "unable to request refclk (%ld)\n",
+				PTR_ERR(hub->clk));
+		return PTR_ERR(hub->clk);
+	}
 
-	if (gpio_is_valid(hub->gpio_intn)) {
-		int val = hub->secondary_ref_clk ? GPIOF_OUT_INIT_LOW :
-						   GPIOF_OUT_INIT_HIGH;
-		err = devm_gpio_request_one(dev, hub->gpio_intn, val,
-					    "usb3503 intn");
+	if (rate != 0) {
+		err = clk_set_rate(hub->clk, rate);
 		if (err) {
 			dev_err(dev,
-				"unable to request GPIO %d as interrupt pin (%d)\n",
-				hub->gpio_intn, err);
+				"unable to set reference clock rate to %d\n",
+				(int)rate);
 			return err;
 		}
 	}
 
-	if (gpio_is_valid(hub->gpio_connect)) {
-		err = devm_gpio_request_one(dev, hub->gpio_connect,
-				GPIOF_OUT_INIT_LOW, "usb3503 connect");
-		if (err) {
-			dev_err(dev,
-				"unable to request GPIO %d as connect pin (%d)\n",
-				hub->gpio_connect, err);
-			return err;
-		}
+	err = clk_prepare_enable(hub->clk);
+	if (err) {
+		dev_err(dev, "unable to enable reference clock\n");
+		return err;
 	}
 
-	if (gpio_is_valid(hub->gpio_reset)) {
-		err = devm_gpio_request_one(dev, hub->gpio_reset,
-				GPIOF_OUT_INIT_LOW, "usb3503 reset");
+	device_property_read_u32(dev, "initial-mode", &mode);
+	hub->mode = mode;
+
+	if (hub->secondary_ref_clk)
+		flags = GPIOD_OUT_LOW;
+	else
+		flags = GPIOD_OUT_HIGH;
+	hub->intn = devm_gpiod_get_optional(dev, "intn", flags);
+	if (IS_ERR(hub->intn))
+		return PTR_ERR(hub->intn);
+	if (hub->intn)
+		gpiod_set_consumer_name(hub->intn, "usb3503 intn");
+
+	hub->connect = devm_gpiod_get_optional(dev, "connect", GPIOD_OUT_LOW);
+	if (IS_ERR(hub->connect))
+		return PTR_ERR(hub->connect);
+	if (hub->connect)
+		gpiod_set_consumer_name(hub->connect, "usb3503 connect");
+
+	hub->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(hub->reset))
+		return PTR_ERR(hub->reset);
+	if (hub->reset) {
 		/* Datasheet defines a hardware reset to be at least 100us */
 		usleep_range(100, 10000);
-		if (err) {
-			dev_err(dev,
-				"unable to request GPIO %d as reset pin (%d)\n",
-				hub->gpio_reset, err);
-			return err;
-		}
+		gpiod_set_consumer_name(hub->reset, "usb3503 reset");
 	}
 
+	if (hub->port_off_mask && !hub->regmap)
+		dev_err(dev, "Ports disabled with no control interface\n");
+
 	usb3503_switch_mode(hub, hub->mode);
 
 	dev_info(dev, "%s: probed in %s mode\n", __func__,
@@ -346,8 +304,7 @@ static int usb3503_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int usb3503_suspend(struct usb3503 *hub)
+static int __maybe_unused usb3503_suspend(struct usb3503 *hub)
 {
 	usb3503_switch_mode(hub, USB3503_MODE_STANDBY);
 	clk_disable_unprepare(hub->clk);
@@ -355,7 +312,7 @@ static int usb3503_suspend(struct usb3503 *hub)
 	return 0;
 }
 
-static int usb3503_resume(struct usb3503 *hub)
+static int __maybe_unused usb3503_resume(struct usb3503 *hub)
 {
 	clk_prepare_enable(hub->clk);
 	usb3503_switch_mode(hub, hub->mode);
@@ -363,30 +320,29 @@ static int usb3503_resume(struct usb3503 *hub)
 	return 0;
 }
 
-static int usb3503_i2c_suspend(struct device *dev)
+static int __maybe_unused usb3503_i2c_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 
 	return usb3503_suspend(i2c_get_clientdata(client));
 }
 
-static int usb3503_i2c_resume(struct device *dev)
+static int __maybe_unused usb3503_i2c_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 
 	return usb3503_resume(i2c_get_clientdata(client));
 }
 
-static int usb3503_platform_suspend(struct device *dev)
+static int __maybe_unused usb3503_platform_suspend(struct device *dev)
 {
 	return usb3503_suspend(dev_get_drvdata(dev));
 }
 
-static int usb3503_platform_resume(struct device *dev)
+static int __maybe_unused usb3503_platform_resume(struct device *dev)
 {
 	return usb3503_resume(dev_get_drvdata(dev));
 }
-#endif
 
 static SIMPLE_DEV_PM_OPS(usb3503_i2c_pm_ops, usb3503_i2c_suspend,
 		usb3503_i2c_resume);
diff --git a/include/linux/platform_data/usb3503.h b/include/linux/platform_data/usb3503.h
index e049d51c1353..d01ef97ddf36 100644
--- a/include/linux/platform_data/usb3503.h
+++ b/include/linux/platform_data/usb3503.h
@@ -17,9 +17,6 @@ enum usb3503_mode {
 struct usb3503_platform_data {
 	enum usb3503_mode	initial_mode;
 	u8	port_off_mask;
-	int	gpio_intn;
-	int	gpio_connect;
-	int	gpio_reset;
 };
 
 #endif
-- 
2.17.1

